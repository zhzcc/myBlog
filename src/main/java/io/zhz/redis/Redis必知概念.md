## Redis 为什么快

* 基于内存实现：Redis 将数据存储在内存中，读写操作不会受到磁盘 IO 速度限制；

  CPU 不是 Redis 的瓶颈，Redis 的瓶颈在于机器内存的大小或者网络带宽

* I/O多路复用模型的使用：Redis 线程不会阻塞在某一个特定的客户端请求处理上；
  可以同时和多个客户端连接并处理请求，从而提升了并发性

* 采用单线程模型：Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的；
  对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行的
  单线程避免了线程切换和竟态产生的消耗，对于服务端开发来说，锁和线程切换 通常为性能累赘

* 高效的数据结构：不同数据类型使用不同的数据结构得以提升速度

## 数据结构

### 数据类型

* string 字符串
* list 列表
* hash 哈希
* set 集合
* zset 有序集合

<img src="C:\Users\zhz\AppData\Roaming\Typora\typora-user-images\image-20241010212152369.png" alt="image-20241010212152369" style="zoom:67%;" />

|          | string                                                       | list                                                         | hash                                                         | set                                                          | zset                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念     | 1、可以存储任意类型的数据，比如文本、数字、图片或者序列化对象<br />2、一个 string 类型的键最大可以存储 512 MB 的数据 | 1、一个有序的字符串列表，ta 按照插入顺序排序，并且支持在两端插入或删除元素<br />2、一个 list 类型的键最多可以存储 2^32-1 个元素 | 1、一个键值对集合，ta 可以存储多个字段和值，类似于java 的 map 对象<br />2、一个 hash 类型的键最多可以存储 2^32-1 个字段 | 1、set 是一个无序的字符串集合，ta 不允许元素重复<br />2、一个 set 类型的键最多可以存储 2^32-1 个元素 | 1、redis 中的 zset 是一种有序集合类型，ta 可以存储不重复的字符串元素，并且给每个元素赋予一个排序权重值（score）；redis 通过权重值来为集合中的元素进行从小到大的排序<br />2、zset 的成员是唯一的，但权重值可以重复<br />3、一个 zset 类型的键最多可以存储 2^32-1 个元素 |
| 底层实现 | string 类型的底层实现是 SDS， ta 是一个动态字符串结构，由长度、空闲空间和字节数据组三部分组成<br />SDS 有 3 中编码类型：<br />1、embstr：占用64 Bytes 的空间，存储 44 Bytes 的数据<br />2、raw：存储大于 44 Bytes 的数据<br />3、int：存储整数类型<br />embstr 和 raw 存储字符串数据，int 存储整型数据 | redis3.2 以后，list 类型的底层实现只有一种结构：quicklist    | hash 类型的底层实现有三种：<br />1、ziplist：压缩列表，当 hash 达到一定的阈值时，会自动转换为 hashtable 结构<br />2、listpack：紧凑列表，在 redis7.0 之后，listpack 正式取代 ziplist；同样的，当 hash 达到一定的阈值时，会自动转换为 hashtable 结构<br />3、hashtable：哈希表，类似 map | set 类型的底层实现有两种：<br />1、intset，整数集合<br />2、hashtable 哈希表；哈希表和 hash 类型的哈希表相同，ta 将元素存储在一个数组中，并通过哈希函数计算元素在数组中的索引 | 1、ziplist（redis7.0前）和 listpack（redis7.0后）<br />2、skiplist |
| 应用场景 | 1、缓存数据，提高访问速度和降低数据库压力<br />2、计数器，利用 incr 和 decr 命令实现原子性的加减操作<br />3、分布式锁，利用 setnx 命令实现互斥访问<br />4、限流，利用 expire 命令实现时间窗口内的访问控制 | 1、消息队列，利用 lpush 和 rpop 命令实现生产者消费者模式<br />2、最新消息，利用 lpush 和 ltrim 命令实现固定长度的时间线<br />3、历史记录，利用 lpush 和 lrange 命令实现浏览记录或者搜索记录 | hash 类型的应用场景主要是存储对象，比如：<br />1、用户信息，利用 hset 和 hget 命令实现对象属性的增删改查<br />2、购物车，利用 hincrby 命令实现商品数量的增减<br />3、配置信息，利用 hmset 和 hmget 命令实现批量设置和获取配置项 | 1、去重，利用 sadd 和 scard 命令实现元素的添加和计数<br />2、交集，并集，差集，利用 sinter，sunion 和 sdiff 命令实现集合间的运算<br />3、随机抽取，利用 srandmember 命令实现随机抽奖或者抽样 | 1、排行榜，利用 zadd 和 zrange 命令实现分数的更新和排名的查询<br />2、延时队列，利用 zadd 和 zpopmin 命令实现任务的添加和执行，并且可以定期 de 获取已经到期的任务<br />3、访问统计，可以使用 zset 来存储网站或者文章的访问次数，并且可以按照访问量进行排序和筛选 |

![image-20241010214801846](C:\Users\zhz\AppData\Roaming\Typora\typora-user-images\image-20241010214801846.png)





## 内存机制

### 内存回收策略



### 内存溢出策略



## 持久化

### RDB 持久化



### AOF 持久化



### RDB&AOF





## 哨兵模式



## 集群



## 基本原理

### redis 协议



## 单线程模式



### 常见问题

### 热 key



### 大 key



### 缓存一致性



### 缓存穿透



### 缓存击穿



### 缓存雪崩



## 分布式锁



## 延时队列





## 新特性





